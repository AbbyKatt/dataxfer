{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Lineage Pre-Solver/Batcher Prototype\n",
    "#Does the AI heavy-lifting so the GraphSolver can answer lineage queries quickly\n",
    "import requests\n",
    "from ast import List\n",
    "\n",
    "API_URL = \"https://entitystore.datawx.uk\"\n",
    "API_KEY= \"entity_store_api_key\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Storage Classes AuditHistory,DirResults,MetaRecord\n",
    "import json\n",
    "\n",
    "class AuditHistory:\n",
    "\n",
    "    def __init__(self,author=\"\",timestamp=\"\",description=\"\"):\n",
    "        self.author = author\n",
    "        self.timestamp = timestamp\n",
    "        self.description = description\n",
    "    \n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"author\":self.author,\n",
    "            \"timestamp\":self.timestamp,\n",
    "            \"description\":self.description\n",
    "        }\n",
    "    \n",
    "    @staticmethod\n",
    "    def from_Json(jsonStr):\n",
    "        self = AuditHistory()\n",
    "        self.author = jsonStr[\"author\"]\n",
    "        self.timestamp = jsonStr[\"timestamp\"]\n",
    "        self.description = jsonStr[\"description\"]\n",
    "        return self\n",
    "\n",
    "#Search result from Dir command\n",
    "class DirResult():\n",
    "\n",
    "    def __init__(self,uuid,Name):\n",
    "        self.uuid = uuid\n",
    "        self.Name = Name\n",
    "\n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"uuid\":self.uuid,\n",
    "            \"Name\":self.Name\n",
    "        }\n",
    "    \n",
    "    def from_Json(self,jsonStr):\n",
    "        self.uuid = jsonStr[\"uuid\"]\n",
    "        self.Name = jsonStr[\"Name\"]\n",
    "\n",
    "#Individual records/simple storage class\n",
    "class MetaRecord:\n",
    "\n",
    "    def __init__(self,uuid=\"\",name=\"\",entityType=\"\",author=\"\",latestUpdate=\"\",keys={},dataFields={},changeHistory=\"\"):\n",
    "        self.uuid = uuid\n",
    "        self.name = name\n",
    "        self.entityType = entityType\n",
    "        self.author = author\n",
    "        self.latestUpdate = latestUpdate\n",
    "        self.changeHistory=changeHistory\n",
    "        self.keys = keys\n",
    "        self.dataFields = dataFields\n",
    "        self.metadata = {}\n",
    "\n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"uuid\":self.uuid,\n",
    "            \"name\":self.name,\n",
    "            \"entityType\":self.entityType,\n",
    "            \"keys\":json.dumps(self.keys),\n",
    "            \"author\":self.author,\n",
    "            \"changeHistory\":self.changeHistory,\n",
    "            \"latestUpdate\":self.latestUpdate,\n",
    "            \"dataFields\":json.dumps(self.dataFields),\n",
    "            \"MetaData\":json.dumps(self.metadata) if self.metadata else \"\"\n",
    "        }\n",
    "    \n",
    "    @staticmethod\n",
    "    def from_Json(jsonStr):\n",
    "        self = MetaRecord()\n",
    "        self.uuid = jsonStr[\"uuid\"]\n",
    "        self.name = jsonStr[\"name\"]\n",
    "        self.entityType = jsonStr[\"entityType\"]\n",
    "        self.author = jsonStr[\"author\"]\n",
    "        self.changeHistory = jsonStr[\"changeHistory\"]\n",
    "        self.latestUpdate = jsonStr[\"latestUpdate\"]\n",
    "\n",
    "        #Load JSON strings into dictionaries\n",
    "        self.keys = {} if \"keys\" not in jsonStr or not jsonStr[\"keys\"] else json.loads(jsonStr[\"keys\"])                  \n",
    "        self.dataFields = {} if \"dataFields\" not in jsonStr or not jsonStr[\"dataFields\"] else json.loads(jsonStr[\"dataFields\"])\n",
    "        self.metadata = {} if \"MetaData\" not in jsonStr or not jsonStr[\"MetaData\"] else json.loads(jsonStr[\"MetaData\"])\n",
    "        return self"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "#REST API class for Entity Store -> to be AI converted into VBA classes\n",
    "import requests\n",
    "\n",
    "class EntityStoreRESTAPI:\n",
    "\n",
    "    def __init__(self,baseurl,apikey):\n",
    "        self.baseurl = baseurl\n",
    "        self.api_key = apikey\n",
    "\n",
    "    def api_dir(self,EntityType:str,keys={})->List:\n",
    "        url=f\"{self.baseurl}/EntityStoreDir\"\n",
    "        response = requests.post(url, params={\"EntityType\": EntityType,\"api_key\":self.api_key},json={\"keys\":keys})\n",
    "        response.raise_for_status()\n",
    "        return [DirResult(itm[\"uuid\"], itm[\"Name\"]) for itm in response.json()]\n",
    "\n",
    "    def api_pull(self,EntityType:str,keys={})->List:\n",
    "        url=f\"{self.baseurl}/EntityStorePull\"\n",
    "        response = requests.post(url, params={\"EntityType\": EntityType,\"api_key\":self.api_key},json={\"keys\":keys})\n",
    "        #print(response.json())\n",
    "        response.raise_for_status()\n",
    "        return [MetaRecord.from_Json(itm) for itm in response.json()]\n",
    "\n",
    "    def api_history(self,UUID):\n",
    "        url=f\"{self.baseurl}/EntityStoreHistory\"\n",
    "        response = requests.post(url, params={\"UUID\": UUID,\"api_key\":self.api_key})\n",
    "        response.raise_for_status()\n",
    "        return [AuditHistory.from_Json(itm) for itm in response.json()]\n",
    "    \n",
    "    def api_push(self,records:List,author):\n",
    "        url=f\"{self.baseurl}/EntityStorePush\"\n",
    "        json=[itm.to_Json() for itm in records]\n",
    "        print(json)\n",
    "        response = requests.post(url, params={\"api_key\":self.api_key,\"author\":author},json=json)\n",
    "        print(response)\n",
    "        response.raise_for_status()\n",
    "        return response.json()\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "#FuncFusion\n",
    "#Latest dev version\n",
    "#Updates: SimpleBatch transform supports newer batcher, funcFusion instance returned inside of FuncFusionResult\n",
    "\n",
    "#----------------------------------------------------------------------------\n",
    "#FuncFusion - Logger\n",
    "#----------------------------------------------------------------------------\n",
    "class ConsoleLogger():\n",
    "    def __init__(self,detailed=False):\n",
    "        self.detailed = detailed\n",
    "\n",
    "    def log(self, msg):\n",
    "        print(msg)\n",
    "    \n",
    "    def logdebuginfo(self, msg):\n",
    "        if self.detailed:\n",
    "            print(msg)\n",
    "\n",
    "    def logheader(self, msg):\n",
    "        print(\"------------------------------------------------------\")\n",
    "        print(msg)\n",
    "        print(\"------------------------------------------------------\")\n",
    "\n",
    "    def log_error(self, msg):\n",
    "        print(msg)\n",
    "\n",
    "\n",
    "#----------------------------------------------------------------------------\n",
    "#FuncFusion Main class\n",
    "#----------------------------------------------------------------------------\n",
    "\n",
    "import asyncio\n",
    "import json\n",
    "import openai\n",
    "import os\n",
    "\n",
    "#Main class - drives configuration\n",
    "class funcfusion():\n",
    "\n",
    "    #Static function initializer\n",
    "    @staticmethod\n",
    "    def fromState(state):\n",
    "        state=json.loads(state)\n",
    "        chatbot=funcfusion(\"\",model_name=state[\"model\"],temperature=state[\"temperature\"])\n",
    "        chatbot.messages=state[\"chatHistory\"]\n",
    "        return chatbot\n",
    "\n",
    "    def __init__(self,SystemPrompt,\n",
    "                 logger=ConsoleLogger(),\n",
    "                 model_name = \"gpt-3.5-turbo\",\n",
    "                 temperature=0.2,\n",
    "                 timeout=30,\n",
    "                 retries=10,\n",
    "                 tarpitDelay=10):\n",
    "        \n",
    "        self.messages=[]\n",
    "        self.model_name=model_name\n",
    "        self.temperature=temperature\n",
    "        openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n",
    "        self.totalTokens=0\n",
    "        self.timeout=timeout\n",
    "        self.retries=retries\n",
    "        self.nextquery=\"\"\n",
    "        self.logger=logger\n",
    "        self.tarpitDelay=tarpitDelay\n",
    "        self.emittedObjects=[]\n",
    "        self.totalRetriesUsed=0\n",
    "\n",
    "        #Load in SystemPrompt\n",
    "        self.SystemPrompt=SystemPrompt\n",
    "        self.addMessage(SystemPrompt,role=\"system\")\n",
    "\n",
    "    def addObject(self,obj):\n",
    "        self.emittedObjects.append(obj)\n",
    "\n",
    "    def addMessage(self,content,role=\"user\",function_name=None):\n",
    "        if function_name is not None:\n",
    "            self.messages.append({\"role\": \"function\",\"name\":function_name, \"content\": content})\n",
    "            self.logger.logdebuginfo(f\"function_call [{function_name}] : {content}\")\n",
    "        else:\n",
    "            self.messages.append({\"role\": role, \"content\": content})\n",
    "            self.logger.logdebuginfo(f\"{role} : {content}\")\n",
    "\n",
    "    def configureAzure(self,apibase,apiversion,apikey):\n",
    "        import openai\n",
    "        openai.api_type = \"azure\"\n",
    "        openai.api_base = apibase\n",
    "        openai.api_version = apiversion\n",
    "        openai.api_key = apikey\n",
    "        return True\n",
    "\n",
    "    async def getCompletion(self,attempt=1,functionsignatures=None):\n",
    "        try:\n",
    "            self.logger.logdebuginfo(f\"Running completion attempt [{attempt}] / {self.retries}\")\n",
    "            self.totalRetriesUsed=attempt\n",
    "            response = await openai.ChatCompletion.acreate(\n",
    "                model=self.model_name,\n",
    "                temperature=self.temperature,\n",
    "                messages=self.messages,\n",
    "                request_timeout=self.timeout,\n",
    "                functions=functionsignatures\n",
    "                )\n",
    "            return response\n",
    "        except Exception as e:\n",
    "\n",
    "            #Print full expception\n",
    "            self.logger.logdebuginfo(f\"Exception {e}\")\n",
    "\n",
    "            #Check if e is of class openai.error.RateLimitError\n",
    "            if type(e)==openai.error.RateLimitError:\n",
    "                delay = (2 ** attempt-1) * self.tarpitDelay\n",
    "                self.logger.logdebuginfo(f\"OpenAI max token rate exceeded - tarpitting {delay} seconds\")\n",
    "                await asyncio.sleep(delay)\n",
    "\n",
    "            self.logger.logdebuginfo(f\"OPENAI ERROR: {type(e)} attempt [{attempt}] / {self.retries}\")\n",
    "            if attempt>=self.retries:\n",
    "                self.logger.log_error(f\"Max retries reached [{attempt}]\")\n",
    "                raise e\n",
    "            else:\n",
    "                return await self.getCompletion(attempt=attempt+1,functionsignatures=functionsignatures)\n",
    "\n",
    "    async def Resolve(self,completion,functionsignatures=None):\n",
    "        try:\n",
    "            #Initial query -> reruns for funtions preinsert function results into message queue\n",
    "            if completion is not None and completion!=\"\":\n",
    "                self.logger.logdebuginfo(\"Running completion:\" + str(completion))\n",
    "                self.addMessage(completion)\n",
    "\n",
    "            #Get completion and token count\n",
    "            ret=await self.getCompletion(attempt=1,functionsignatures=functionsignatures)\n",
    "            self.totalTokens=ret.usage.total_tokens\n",
    "            return ret\n",
    "        except Exception as e:\n",
    "            self.logger.log_error(f\"OPENAI ERROR: {type(e)}\")\n",
    "            raise e\n",
    "\n",
    "    async def ResolveText(self,ret):\n",
    "        ret=await self.Resolve(ret)\n",
    "        return ret.choices[0].message.content\n",
    "\n",
    "    async def ResolveTextBatch(self,ret):\n",
    "        ret=await self.Resolve(ret)\n",
    "        return FuncFusionResult(ret.choices[0].message.content,self,\"OK\")\n",
    "    \n",
    "    #to json\n",
    "    def toJSON(self):\n",
    "        return json.dumps({\n",
    "            \"chatHistory\": self.messages,\n",
    "            \"model\": self.model_name,\n",
    "            \"temperature\": self.temperature\n",
    "        })\n",
    "\n",
    "    #deep clone of object\n",
    "    def clone(self):\n",
    "        return funcfusion.fromState(self.toJSON())\n",
    "    \n",
    "#----------------------------------------------------------------------------\n",
    "#FBatch -> runs queries in batches to not be banned or break the API\n",
    "#----------------------------------------------------------------------------\n",
    "\n",
    "class FuncFusionResult():\n",
    "    def __init__(self,finalcompletion,funcfusioninstance,status):\n",
    "        self.finalcompletion=finalcompletion\n",
    "        self.funcfusioninstance=funcfusioninstance\n",
    "        self.status=status\n",
    "\n",
    "import asyncio\n",
    "\n",
    "class FBatch():\n",
    "    def __init__(self,batchsize=100,logger=ConsoleLogger(),batchDelay=0):\n",
    "        self.batchsize=batchsize\n",
    "        self.logger=logger\n",
    "        self.batchDelay=batchDelay\n",
    " \n",
    "    async def run(self,coroutines):\n",
    "        self.logger.logheader(f\"fBatch Start => {len(coroutines)} elements\")\n",
    "\n",
    "        #Break into batches\n",
    "        results=[]\n",
    "        for i in range(0,len(coroutines),self.batchsize):\n",
    "            self.logger.log(f\"Running batch {i} of {len(coroutines)}\")\n",
    "            results+=await asyncio.gather(*coroutines[i:i+self.batchsize])\n",
    "\n",
    "            #Print useful stats\n",
    "            retries=[x.funcfusioninstance.totalRetriesUsed for x in results]\n",
    "            tokens=[x.funcfusioninstance.totalTokens for x in results]\n",
    "            #self.logger.log(f\"Total Tokens: {sum(tokens)}\")\n",
    "\n",
    "            #Print all the stats on a single formatted liine\n",
    "            self.logger.log(f\"Stats: Average Queries Attempts: {sum(retries)/len(retries)} Retries: {sum(retries)-len(results)} Max Tries: {max(retries)} Total Tokens: {sum(tokens)}\")\n",
    "\n",
    "        self.logger.logheader(f\"fBatch End => {len(coroutines)} elements\")\n",
    "        return results\n",
    "\n",
    "#----------------------------------------------------------------------------\n",
    "#FuncFusion Simple Prompt Transform -> run LOTS of queries at once in batches and with token limits to get max throughput\n",
    "#----------------------------------------------------------------------------\n",
    "\n",
    "class SimplePromptTransform():\n",
    "\n",
    "    def __init__(self,config:funcfusion,batchsize=100):\n",
    "        self.config=config\n",
    "        self.batch=[]\n",
    "        self.batchsize=batchsize\n",
    "\n",
    "    async def RunTransforms(self,inputqueries):\n",
    "        #Clone up the original config and make a node for each query\n",
    "        nodes=[]\n",
    "        for query in inputqueries:\n",
    "            clone=self.config.clone()\n",
    "            ret= clone.ResolveTextBatch(query)\n",
    "            nodes.append(ret)\n",
    "\n",
    "        #Run in batches\n",
    "        batch=FBatch(batchsize=self.batchsize)\n",
    "        results=await batch.run(nodes)\n",
    "        return results\n",
    "        \n",
    " \n",
    "#----------------------------------------------------------------------------\n",
    "#FuncFusion Function enumerator classes automatically finds your AI callable functions\n",
    "#----------------------------------------------------------------------------\n",
    "class FunctionEnumerator():\n",
    "\n",
    "    @staticmethod\n",
    "    def EnumerateClassFunctions(instance):\n",
    "        #Call functions on instance and get the openai_schema\n",
    "        classfunctions=[func for func in dir(instance) if hasattr(getattr(instance,func), 'openai_schema')]\n",
    "        return [getattr(instance,func) for func in classfunctions]\n",
    "\n",
    "    #Lists top-level global functions (simple programs and jupyter notebooks)\n",
    "    @staticmethod\n",
    "    def EnumerateGlobalFunctions():\n",
    "        return [func for func in globals().values() if hasattr(func, 'openai_schema')]\n",
    "\n",
    "#----------------------------------------------------------------------------\n",
    "#FuncFusion Dispatcher class -> calls functions. This is the non-async version\n",
    "#----------------------------------------------------------------------------\n",
    "class SerialDispatcher():\n",
    "\n",
    "    def __init__(self,functions,Logger=ConsoleLogger()):\n",
    "        self.functions=functions\n",
    "        self.logger=Logger\n",
    "\n",
    "        #Turn functions into a dictionary\n",
    "        self.functionDict={}\n",
    "        for func in functions:\n",
    "            self.functionDict[func.openai_schema[\"name\"]]=func\n",
    "    \n",
    "    #Gets the schema for passed in functions\n",
    "    def getFunctionSchema(self):\n",
    "        schemas=[]\n",
    "        if self.functions is not None:\n",
    "            for aFunc in self.functions:\n",
    "                schemas.append(aFunc.openai_schema)\n",
    "            #print(schemas)\n",
    "            return schemas\n",
    "        else:\n",
    "            return None    \n",
    "\n",
    "    def dispatch(self,function_name,result):\n",
    "        self.logger.logdebuginfo(f\"Dispatching {function_name}\")\n",
    "        if function_name not in self.functionDict:\n",
    "            self.logger.log_error(f\"Function {function_name} not found\")            \n",
    "            return None\n",
    "        else:\n",
    "            self.logger.logdebuginfo(f\"Running {function_name}\")\n",
    "            self.logger.logdebuginfo(f\"Found {function_name}\")\n",
    "            function=self.functionDict[function_name]\n",
    "            ret=function.from_response(result)\n",
    "            return ret\n",
    "\n",
    "#----------------------------------------------------------------------------\n",
    "#FuncFusion Function calling transformation -> run queries, they call functions and you get results\n",
    "#----------------------------------------------------------------------------\n",
    "\n",
    "#Add a custom object to the queue and continue processing\n",
    "class EmitContinue():\n",
    "    def __init__(self,message,emitobject):\n",
    "        self.message=message\n",
    "        self.emitobject=emitobject\n",
    "\n",
    "#Add a custom object to the queue and return without more posts to GPT\n",
    "class EmitStop():\n",
    "    def __init__(self,message,emitobject):\n",
    "        self.message=message\n",
    "        self.emitobject=emitobject\n",
    "\n",
    "class FunctionCallingTransform():\n",
    "\n",
    "    def __init__(self,fusioninstance:funcfusion,dispatcher:SerialDispatcher,logger=ConsoleLogger(),batchsize=100,batchDelay=10):\n",
    "        self.fusioninstance=fusioninstance\n",
    "        self.dispatcher=dispatcher\n",
    "        self.logger=logger\n",
    "        self.batchsize=batchsize\n",
    "        self.batchDelay=batchDelay\n",
    "\n",
    "    def ProcessResponse(self,response,function_name,fusioninstance:funcfusion):\n",
    "        #Check for emit objects\n",
    "\n",
    "        #If functioncalling returns a string just pass it on to the AI\n",
    "        if type(response)==str:\n",
    "            fusioninstance.addMessage(response,role=\"function\",function_name=function_name)\n",
    "            return True #Continue processing\n",
    "        \n",
    "        #Add object and an AI response and keep rolling\n",
    "        elif type(response)==EmitContinue:\n",
    "            fusioninstance.addMessage(response.message,role=\"function\",function_name=function_name)\n",
    "            fusioninstance.addObject(response.emitobject)\n",
    "            return True\n",
    "        \n",
    "        #Add object and an AI response and stop processing\n",
    "        #The AI reponse will go into the message queue of the fusion instance\n",
    "        #but no more processing will happen (unless you reuse the object)\n",
    "        #You can specify \"None\" or \"\" to omit adding a message\n",
    "        elif type(response)==EmitStop:\n",
    "            fusioninstance.addMessage(response.message,role=\"function\",function_name=function_name)\n",
    "            fusioninstance.addObject(response.emitobject)\n",
    "            return False\n",
    "        \n",
    "        #If it's any other kind of object turn it into JSON and send to the AI\n",
    "        else:\n",
    "            function_response=json.dumps(response)\n",
    "            fusioninstance.addMessage(function_response,role=\"function\",function_name=function_name)\n",
    "            return True\n",
    "\n",
    "    #Corouritine loop that runs functions until the chain is ended\n",
    "    async def FunctionResolver(self,fusioninstance:funcfusion,query):\n",
    "        result=await fusioninstance.Resolve(query,functionsignatures=self.dispatcher.getFunctionSchema())\n",
    "        \n",
    "        #DEBUG  - remove this\n",
    "        # print(\"**********************************************\")\n",
    "        # print(str(result))\n",
    "        # print(\"**********************************************\")\n",
    "        \n",
    "        finish_reason=result.choices[0].finish_reason\n",
    "        if finish_reason==\"function_call\":\n",
    "            #Run a function and return results\n",
    "            function_name=result.choices[0].message.function_call.name\n",
    "\n",
    "            #Dispatch -> add result into message queue\n",
    "            function_response=self.dispatcher.dispatch(function_name,result)\n",
    "            if self.ProcessResponse(function_response,function_name,fusioninstance):\n",
    "                #Continue recursive processing \n",
    "                return await self.FunctionResolver(fusioninstance,query=None)\n",
    "            else:\n",
    "                #Stop recursive processing\n",
    "                return FuncFusionResult(result.choices[0].message.content,fusioninstance,finish_reason)\n",
    "            \n",
    "        \n",
    "        else:\n",
    "            #Done\n",
    "            self.logger.logdebuginfo(f\"Resolver -> {finish_reason}\")\n",
    "\n",
    "        return FuncFusionResult(result.choices[0].message.content,fusioninstance,finish_reason)\n",
    "        \n",
    "\n",
    "    async def RunTransforms(self,inputqueries):\n",
    "        #Clone up the original config and make a node for each query\n",
    "        nodes=[]\n",
    "        for query in inputqueries:\n",
    "            config=self.fusioninstance.clone()\n",
    "            ret= self.FunctionResolver(config,query)\n",
    "            nodes.append(ret)\n",
    "\n",
    "        #Run in batches\n",
    "        batch=FBatch(batchsize=self.batchsize,batchDelay=self.batchDelay,logger=self.logger)\n",
    "        results=await batch.run(nodes)\n",
    "        return results\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>comment</th>\n",
       "      <th>SQL SourceCode View</th>\n",
       "      <th>Link_Logic</th>\n",
       "      <th>functional category</th>\n",
       "      <th>Source Table</th>\n",
       "      <th>Target Table</th>\n",
       "      <th>Target Field</th>\n",
       "      <th>Derivation</th>\n",
       "      <th>uuid</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>We don't think the tests for AccountUsage.summ...</td>\n",
       "      <td>src_AccountUsage</td>\n",
       "      <td>AccountUsage is created by joining Account_Fac...</td>\n",
       "      <td>agrgegation</td>\n",
       "      <td>Account_Facility</td>\n",
       "      <td>AccountUsage</td>\n",
       "      <td>summed_facility_limit</td>\n",
       "      <td>sum(facility_limit)</td>\n",
       "      <td>18ed5850-5b46-44f9-86ff-c997ae03d529</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>NaN</td>\n",
       "      <td>src_Account_Facility</td>\n",
       "      <td>Account_Facility is produced by joining Accoun...</td>\n",
       "      <td>etl</td>\n",
       "      <td>AccountDetails</td>\n",
       "      <td>Account_Facility</td>\n",
       "      <td>account_open_date</td>\n",
       "      <td>direct</td>\n",
       "      <td>0967080f-ccc0-409e-9c69-8588fcd1f9d0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>Whats the difference  and lineage between Acco...</td>\n",
       "      <td>src_Account_Facility</td>\n",
       "      <td>Account_Facility is produced by joining Accoun...</td>\n",
       "      <td>etl</td>\n",
       "      <td>AccountDetails</td>\n",
       "      <td>Account_Facility</td>\n",
       "      <td>branch_code</td>\n",
       "      <td>branch_code field  from the AccountDetails tab...</td>\n",
       "      <td>e1a28833-fa3c-444f-8989-0f4987e94b89</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>NaN</td>\n",
       "      <td>src_Account_Facility</td>\n",
       "      <td>Account_Facility is produced by joining Accoun...</td>\n",
       "      <td>etl</td>\n",
       "      <td>AccountDetails</td>\n",
       "      <td>Account_Facility</td>\n",
       "      <td>flagPEPExposed</td>\n",
       "      <td>direct</td>\n",
       "      <td>44f3bc62-9a19-479d-ad49-8c914c5c0ad8</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>NaN</td>\n",
       "      <td>src_Facility_Txn</td>\n",
       "      <td>Facility_Txn is created by joining FacilityDet...</td>\n",
       "      <td>etl</td>\n",
       "      <td>FacilityDetails</td>\n",
       "      <td>Facility_Txn</td>\n",
       "      <td>facility_open_date</td>\n",
       "      <td>direct</td>\n",
       "      <td>146ef420-e637-49a3-b5f4-e19f02778552</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                                             comment   SQL SourceCode View  \\\n",
       "0  We don't think the tests for AccountUsage.summ...      src_AccountUsage   \n",
       "1                                                NaN  src_Account_Facility   \n",
       "2  Whats the difference  and lineage between Acco...  src_Account_Facility   \n",
       "3                                                NaN  src_Account_Facility   \n",
       "4                                                NaN      src_Facility_Txn   \n",
       "\n",
       "                                          Link_Logic functional category  \\\n",
       "0  AccountUsage is created by joining Account_Fac...         agrgegation   \n",
       "1  Account_Facility is produced by joining Accoun...                 etl   \n",
       "2  Account_Facility is produced by joining Accoun...                 etl   \n",
       "3  Account_Facility is produced by joining Accoun...                 etl   \n",
       "4  Facility_Txn is created by joining FacilityDet...                 etl   \n",
       "\n",
       "       Source Table      Target Table           Target Field  \\\n",
       "0  Account_Facility      AccountUsage  summed_facility_limit   \n",
       "1    AccountDetails  Account_Facility      account_open_date   \n",
       "2    AccountDetails  Account_Facility            branch_code   \n",
       "3    AccountDetails  Account_Facility         flagPEPExposed   \n",
       "4   FacilityDetails      Facility_Txn     facility_open_date   \n",
       "\n",
       "                                          Derivation  \\\n",
       "0                                sum(facility_limit)   \n",
       "1                                             direct   \n",
       "2  branch_code field  from the AccountDetails tab...   \n",
       "3                                             direct   \n",
       "4                                             direct   \n",
       "\n",
       "                                   uuid  \n",
       "0  18ed5850-5b46-44f9-86ff-c997ae03d529  \n",
       "1  0967080f-ccc0-409e-9c69-8588fcd1f9d0  \n",
       "2  e1a28833-fa3c-444f-8989-0f4987e94b89  \n",
       "3  44f3bc62-9a19-479d-ad49-8c914c5c0ad8  \n",
       "4  146ef420-e637-49a3-b5f4-e19f02778552  "
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Load updated data from the API - at the moment we load whole project. In future this wil bel a delta load\n",
    "#Load data from EntityStore into a dataframe\n",
    "EntStoreURL=\"https://entitystore.datawx.uk\"\n",
    "tableUUID=\"782b86f8-a297-4131-bf1a-cb66f1dc6f13\"\n",
    "entStore=EntityStoreRESTAPI(EntStoreURL,API_KEY)\n",
    "\n",
    "#Load this specific fields for this table\n",
    "entities=entStore.api_pull(\"Field\",{\"TableUUID\":tableUUID})\n",
    "rows=[]\n",
    "for metaRec in entities:\n",
    "    datafields=metaRec.dataFields\n",
    "    datafields[\"uuid\"]=metaRec.uuid\n",
    "    rows.append(datafields)\n",
    "\n",
    "#Turn rows into a DataFrame\n",
    "import pandas as pd\n",
    "df=pd.DataFrame(rows)\n",
    "df.head()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      "Field Definition:\n",
      "Link_Logic: AccountUsage is created by joining Account_Facility and Facility_Txn on common key facility_id\n",
      "Source Table: Account_Facility\n",
      "Target Table: AccountUsage\n",
      "Target Field: summed_facility_limit\n",
      "Derivation: sum(facility_limit)\n",
      "\n",
      "Built 97 prompts\n"
     ]
    }
   ],
   "source": [
    "#Prompt Builder - builds a prompt based on the row for the AI to solve / this selects what fields are passed to the AI \n",
    "\n",
    "def BuildPrompt(valuesDict):\n",
    "    SystemPrompt=\"\\n\\nField Definition:\\n\"\n",
    "    \n",
    "    passFields={\"Source Table\":True,\n",
    "                \"Target Table\":True,\n",
    "                \"Target Field\":True,\n",
    "                \"Link_Logic\":True,\n",
    "                \"Derivation\":True\n",
    "                }\n",
    "    \n",
    "    Fielddef=\"\"\n",
    "    for key in valuesDict:\n",
    "        if key in passFields:\n",
    "            Fielddef+=f\"{key}: {valuesDict[key]}\\n\"\n",
    "    \n",
    "    Prompt=SystemPrompt+Fielddef\n",
    "    return Prompt\n",
    "\n",
    "#Build a prompt for the first row\n",
    "valuesDict=df.iloc[0].to_dict()\n",
    "prompt=BuildPrompt(valuesDict)\n",
    "print(prompt)\n",
    "\n",
    "#Build prompts for all rows\n",
    "prompts=[]\n",
    "for index, row in df.iterrows():\n",
    "    valuesDict=row.to_dict()\n",
    "    prompt=BuildPrompt(valuesDict)\n",
    "    prompts.append(prompt)\n",
    "print(f\"Built {len(prompts)} prompts\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "system : You're a DBA agent and your task is to validate spec documents.\n",
      "The spec comes in the format of multiple fields, with source, destination fields, linking logic and a dervivation.\n",
      "Sometimes the derivation is in natural language othertimes it's in pseudo SQL. \n",
      "\n",
      "It's also wrong a lot of the time.  Your task is to verbosely validate the spec and provide feedback to the user\n",
      "If something is undefined, if the logic is not water-tight, or it's just plain wrong say so.\n",
      "Be clear and concise and list out the issues in bullet points.\n",
      "If someone asks for a derivation of \"direct\" is usually just means to copy the field from the source table directle (same name).\n",
      "If it's OK just say so too.\n",
      "\n",
      "------------------------------------------------------\n",
      "fBatch Start => 97 elements\n",
      "------------------------------------------------------\n",
      "Running batch 0 of 97\n",
      "Stats: Average Queries Attempts: 1.0 Retries: 0 Max Tries: 1 Total Tokens: 32255\n",
      "------------------------------------------------------\n",
      "fBatch End => 97 elements\n",
      "------------------------------------------------------\n"
     ]
    }
   ],
   "source": [
    "#Stage 1 - following a REACT example we use SimplePromptTransform to turn prompts into a baked list of entities\n",
    "\n",
    "systemPrompt=\"\"\"You're a DBA agent and your task is to validate spec documents.\n",
    "The spec comes in the format of multiple fields, with source, destination fields, linking logic and a dervivation.\n",
    "Sometimes the derivation is in natural language othertimes it's in pseudo SQL. \n",
    "\n",
    "It's also wrong a lot of the time.  Your task is to verbosely validate the spec and provide feedback to the user\n",
    "If something is undefined, if the logic is not water-tight, or it's just plain wrong say so.\n",
    "Be clear and concise and list out the issues in bullet points.\n",
    "If someone asks for a derivation of \"direct\" is usually just means to copy the field from the source table directle (same name).\n",
    "If it's OK just say so too.\n",
    "\"\"\"\n",
    "\n",
    "\n",
    "logger=ConsoleLogger(detailed=True)\n",
    "fusion=funcfusion(systemPrompt,tarpitDelay=30,retries=20,logger=logger) #,model_name=\"gpt-4\"\n",
    "Transform=SimplePromptTransform(fusion,batchsize=100)\n",
    "results=await Transform.RunTransforms(prompts)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "**Validation Feedback:**\n",
      "\n",
      "- The linking logic provided is clear and specifies that AccountUsage is created by joining Account_Facility and Facility_Txn on the common key facility_id.\n",
      "- The derivation for the field summed_facility_limit is defined as sum(facility_limit), which is clear and straightforward.\n",
      "- As the derivation is a simple sum of the facility_limit field, it is valid and does not raise any issues.\n",
      "- Overall, the specification for the field summed_facility_limit is correct and can be implemented as described.\n"
     ]
    }
   ],
   "source": [
    "print(results[0].finalcompletion)\n",
    "\n",
    "#Zip together the results and the prompts\n",
    "dfRes=[]\n",
    "for i in range(0,len(prompts)):\n",
    "    prompt=prompts[i]\n",
    "    \n",
    "    #Replace prompt windows line feed with linux ones\n",
    "    prompt=prompt.replace(\"\\r\\n\",\"\\n\")\n",
    "    result=results[i].finalcompletion\n",
    "    dictResult={\"Prompt\":prompt,\"Result\":result}\n",
    "    dfRes.append(dictResult)\n",
    "df=pd.DataFrame(dfRes)\n",
    "df.head()\n",
    "df.to_csv(\"PREFECT.csv\",index=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "system : You're a DBA agent and your task to look over feedback to a user given on a single field in a spec document.\n",
      "The feedback will tell you whats wrong, right, suspect or needs more information.\n",
      "\n",
      "Consider the feedback carefully then VOTE using the functions provided.\n",
      "Provide messages to the user as to why you voted the way you did.\n",
      "\n",
      "\n",
      "Spec FeedBack:\n",
      "\n",
      "------------------------------------------------------\n",
      "fBatch Start => 97 elements\n",
      "------------------------------------------------------\n",
      "Running batch 0 of 97\n",
      "Stats: Average Queries Attempts: 1.0 Retries: 0 Max Tries: 1 Total Tokens: 46868\n",
      "------------------------------------------------------\n",
      "fBatch End => 97 elements\n",
      "------------------------------------------------------\n"
     ]
    }
   ],
   "source": [
    "#Stage 2 - FunctionCalling Transform to turn the baked list into structured Python classes\n",
    "from openai_function_call import openai_function\n",
    "from typing import List\n",
    "from pydantic import BaseModel\n",
    "\n",
    "class VoteResult():\n",
    "    \n",
    "    def __init__(self,Vote,Message):\n",
    "        self.Vote=Vote\n",
    "        self.Message=Message\n",
    "    \n",
    "    def to_Json(self):\n",
    "        return {\"Vote:\":self.Vote,\n",
    "                \"Message\":self.Message}\n",
    "   \n",
    "\n",
    "@openai_function\n",
    "def VoteGreen():\n",
    "    \"\"\"You must use this function to vote Green - which means the spec is OK.\n",
    "    \"\"\"\n",
    "    #print(f\"Dependent Fields: {Dependencies}\")\n",
    "    #print(f\"Linking Fields: {LinkFields}\")\n",
    "    return EmitStop(\"True\",VoteResult(\"Green\",\"\"))    \n",
    "\n",
    "@openai_function\n",
    "def VoteAmber(Message):\n",
    "    \"\"\"You must use this function to vote Amber - which means the spec needs more work. While not totally wrong, it's not right either\n",
    "    More data is usually required, or clarification on the derivation, or improvement in some manner.\n",
    "    Specify why this is Amber in the message succinctlty but also briefly and clearly. Keep it as short as possible but give them all the information. \n",
    "    \"\"\"\n",
    "    #print(f\"Dependent Fields: {Dependencies}\")\n",
    "    #print(f\"Linking Fields: {LinkFields}\")\n",
    "    return EmitStop(\"True\",VoteResult(\"Amber\",Message))    \n",
    "\n",
    "\n",
    "@openai_function\n",
    "def VoteRed(Message):\n",
    "    \"\"\"You must use this function to vote Red - which means the spec is wrong.\n",
    "    The derivation is incorrect, the linking logic is flawed, or the fields are not defined.\n",
    "    If the logic is not water-tight logically, pieces of information are ambigous etc\n",
    "    Specify why this is Red in the message succinctlty but also briefly and clearly. Keep it as short as possible but give them all the information. \n",
    "    \"\"\"\n",
    "    #print(f\"Dependent Fields: {Dependencies}\")\n",
    "    #print(f\"Linking Fields: {LinkFields}\")\n",
    "    return EmitStop(\"True\",VoteResult(\"Red\",Message))    \n",
    "\n",
    "\n",
    "systemPrompt=\"\"\"You're a DBA agent and your task to look over feedback to a user given on a single field in a spec document.\n",
    "The feedback will tell you whats wrong, right, suspect or needs more information.\n",
    "\n",
    "Consider the feedback carefully then VOTE using the functions provided.\n",
    "Provide messages to the user as to why you voted the way you did.\n",
    "\n",
    "\n",
    "Spec FeedBack:\n",
    "\"\"\"\n",
    "\n",
    "#Build prompts from prior results\n",
    "reactPrompts=[]\n",
    "for ret in results:\n",
    "    reactPrompts.append(ret.finalcompletion)\n",
    "\n",
    "#Use func fusion batch solver\n",
    "logger=ConsoleLogger(detailed=True)\n",
    "fusion=funcfusion(systemPrompt,tarpitDelay=30,retries=20,logger=logger) #,\n",
    "Transform=FunctionCallingTransform(fusion,SerialDispatcher([VoteRed,VoteAmber,VoteGreen]),batchsize=100,batchDelay=5)\n",
    "results_vote=await Transform.RunTransforms(reactPrompts)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Votes: 84 NoneVotes: 13\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': 'The feedback suggests that the linking logic is unclear and incomplete, and the derivation could be more explicitly stated. More detailed linking logic is recommended to clarify the relationship between the fields.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': 'The spec is incomplete and lacks necessary information. Source table, linking logic, and specific field for derivation are not defined.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': \"The feedback highlights critical issues with the specification, including the lack of a defined source table, unclear linking logic, and incomplete derivation details. Without this essential information, the derivation of the 'txn_id' field in the 'in_TxnDetails' table cannot be accurately implemented.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': \"The source table is not defined for the field, the linking logic is not specified, and the derivation method is mentioned as 'None', which is critical for data population. This lack of information hinders the data mapping process and can lead to incorrect data mapping.\"}\n",
      "{'Vote:': 'Red', 'Message': \"The spec is wrong because the source table for the field 'branch_code' in the 'in_AccountDetails' target table is not defined. Additionally, the linking logic for how the data should be derived or linked for the 'branch_code' field is also not defined.\"}\n",
      "{'Vote:': 'Amber', 'Message': 'I will vote Amber because the derivation for the field CalcRiskBand is specified as \"Direct\", but it is not clear which source table it should be copied from. More information is needed to clarify this aspect of the specification.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': \"The linking logic between 'AccountDetails' and 'FacilityDetails' tables needs clarification for accurate data retrieval. Additionally, verification of the existence of the 'facility_country' field in the 'FacilityDetails' table is required for direct derivation validity.\"}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec needs more work. The source table is not defined, and the linking logic is unclear. More specific details are required to clarify the derivation of the 'source field' and the relationship between the source and target fields.\"}\n",
      "{'Vote:': 'Amber', 'Message': \"The field derivation 'Direct' is clear, but more information is needed to confirm if the spec for 'RepoTermsAgreed' from table 'in_FacilityDetails' to 'FacilityDetails' is complete. Please provide more details on the mapping and any transformations involved.\"}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec is mostly clear but lacks explicit linking logic. More clarification is needed on how the source table 'in_FacilityDetails' is related to the target table 'FacilityDetails'. Please provide more details on the linking logic for a complete understanding.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': 'Based on the feedback provided, I will vote Amber because the spec needs more work.\\n\\nThe feedback points out that the source table and linking logic for the field \"CreditRiskBand\" in the in_AccountDetails table are not defined. Additionally, the derivation is specified as \"None,\" which may imply a direct copy without transformation. However, it is recommended to explicitly mention \"direct\" in the derivation if that is the intention.\\n\\nTherefore, more information is needed to clarify the source table, linking logic, and derivation for the field \"CreditRiskBand\" in the in_AccountDetails table.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': 'The spec for deriving the `account_id` field is incomplete and unclear. Please provide the specific source table, source field, and clarify the derivation logic for a more accurate definition.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': \"The linking logic provided for the field 'customer_name' is not relevant to its derivation. More clarification is needed on how the 'customer_name' field is derived from 'Account_Facility' to 'AccountUsage'.\"}\n",
      "{'Vote:': 'Amber', 'Message': 'The feedback is Amber because it highlights the need for more information and clarification on the source table, linking logic, and derivation logic. Please provide the name of the source table, clarify the linking logic if any, and specify the specific field from the source table for mapping to the target field.'}\n",
      "{'Vote:': 'Amber', 'Message': \"The field definition for 'flagUnusualActivity' in the table 'in_FacilityDetails' is incomplete and lacks clarity. More information is needed to specify the source table, linking logic, and derivation. Please provide additional details for a complete specification.\"}\n",
      "{'Vote:': 'Amber', 'Message': 'Based on the feedback provided for the \"account_open_date\" field:\\n\\n- The linking logic for deriving the \"account_open_date\" field from the tables \"Account_Facility\" and \"Facility_Txn\" on the common key \"facility_id\" is deemed irrelevant. This indicates a potential issue with the linking logic specified for this field.\\n\\n- The derivation method specified as \"direct\" implies that the value of the \"account_open_date\" field should be directly copied from the source table \"Account_Facility\" to the target table \"AccountUsage.\" This method of derivation is considered valid based on the provided information.\\n\\nConsidering the discrepancy in the linking logic relevance, it is recommended to further clarify the intended derivation process for the \"account_open_date\" field to ensure accuracy and consistency in the data mapping. \\n\\nTherefore, I vote **Amber** as the spec for the \"account_open_date\" field may need more clarification regarding the linking logic and its relevance to the field derivation.'}\n",
      "{'Vote:': 'Amber', 'Message': 'I will vote Amber because the feedback indicates that the spec needs more work. The source table for the \"account_id\" field in the \"in_AccountDetails\" table is not defined, the linking logic is missing, and the derivation for the field is not provided. More information is required to complete the specification and make it implementable. Please provide the missing details for the source table, linking logic, and derivation of the \"account_id\" field.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': 'The spec needs more work. More information is required to clarify the source table, source field, and linking logic for populating the target field. The derivation should specify the specific source field name for clarity.'}\n",
      "{'Vote:': 'Amber', 'Message': 'The spec needs more work. The source table and link logic are not defined, and clarification is needed on whether the derivation is meant to be direct.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': 'The spec is incomplete and lacks clarity on the source table, linking logic, and specific source field for deriving the `txn_country` field in the `in_TxnDetails` table.'}\n",
      "{'Vote:': 'Green', 'Message': 'This feedback is clear and confirms that the linking logic, source table, target table, target field, and derivation method are all correctly identified and specified. The feedback indicates that there are no issues to report, and the field definition is clear and appropriate for the scenario.\\n\\nI will vote: Green'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': 'The spec for flagSuspectTransfer in in_TxnDetails is incomplete as the source table, linking logic, and derivation are not defined. This crucial information is necessary for implementation.'}\n",
      "{'Vote:': 'Red', 'Message': \"The spec for the field 'Past_Due60Day' in the target table 'in_FacilityDetails' is incomplete. The source table, linking logic, and derivation for this field are not defined, making it impossible to implement.\"}\n",
      "{'Vote:': 'Green', 'Message': 'I agree with the feedback provided:\\n\\n- The linking logic is clear and specifies the relationship between FacilityDetails and TxnDetails using the common key facility_id.\\n- The correct source table, TxnDetails, and target table, Facility_Txn, are identified.\\n- The target field, txn_id, is correctly specified.\\n- The derivation method \"direct\" is valid and indicates copying the value directly from the source field to the target field.\\n\\nBased on the information provided, I am voting **Green** as the field definition is valid and does not have any issues.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': 'Based on the feedback provided, here is the breakdown for your consideration:\\n\\n1. The source table is not defined, which is a critical missing piece of information. Without specifying the source table, it is unclear where the \"source field\" is coming from. This lack of definition makes the spec incomplete and ambiguous. Therefore, I will **VoteRed** for this issue as it is a fundamental flaw in the specification.\\n\\n2. The linking logic is mentioned as \"None\", indicating that there is no specific guidance on how the source field should be linked to the target field. This ambiguity can lead to confusion and potential errors in implementation. More details are needed to clarify the linking logic. I will **VoteAmber** for this point as it requires further clarification to improve the spec.\\n\\n3. The derivation is simply mentioned as \"source field\", which is vague and lacks specificity. It is essential to provide a clear derivation logic or specify if it is a direct copy from the source field to ensure accurate implementation. This lack of clarity contributes to the overall incompleteness of the spec. Therefore, I will **VoteAmber** for this issue as well.\\n\\nIn summary, the spec requires significant improvements in defining the source table, providing details on linking logic, and specifying a clear derivation logic. Addressing these issues will enhance the clarity and completeness of the specification.'}\n",
      "{'Vote:': 'Red', 'Message': \"The spec is Red because the source table for the field 'flagHighRiskCountry' is not defined, the linking logic is missing, and the derivation for the field is not provided. Without this crucial information, the implementation cannot proceed effectively.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec for the field 'flagFraudSuspected' in the 'Facility_Txn' table needs more work. The linking logic involving 'FacilityDetails' needs clarification and accuracy. Additionally, it should be confirmed if the field 'flagFraudSuspected' exists in the source table 'TxnDetails' for the direct derivation to be valid.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': 'Based on the feedback provided, everything seems to be in order and the field definition is valid. The linking logic is clear, the tables and fields are correctly identified, and the derivation method is appropriate for the scenario. Therefore, I will vote:\\n\\n**Green**'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': \"The source table for the target field 'customer_name' is not defined, and the linking logic is missing. The derivation for the field is also not provided. This information is crucial for understanding how the field is populated and its relationship with other data.\"}\n",
      "{'Vote:': 'NOVOTE', 'Message': 'I agree with the feedback provided. The linking logic is clear, the tables and fields are correctly identified, and the derivation method is acceptable. The field definition seems to be valid with no identified issues.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': \"The linking logic between 'in_FacilityDetails' and 'FacilityDetails' is not explicitly defined. While the 'direct' derivation implies a direct copy, more clarity is needed on how the tables are linked.\"}\n",
      "{'Vote:': 'Red', 'Message': \"The source table, linking logic, and derivation for the 'account_type' field in the 'in_AccountDetails' table are not defined. This crucial information is necessary for implementation and must be provided in the specification.\"}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec for the 'account_open_date' field needs more work. The source table and source field are not defined, and clarification is needed on whether the field should be populated directly without any transformation. Additionally, if the derivation is meant to be a direct copy, it should be explicitly specified as 'direct' for clarity.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': 'Based on the feedback provided, here is the breakdown for your consideration:\\n\\n1. The source table is not defined, which is crucial for the derivation process. Without specifying the source table, it is unclear where the data is coming from. This is a critical missing piece of information that needs to be addressed.\\n\\n2. The linking logic is mentioned as \"None,\" indicating that there is no specific logic mentioned for mapping the source field to the target field. If the intention is to directly copy the field from the source table, it should be explicitly stated as \"direct\" in the derivation.\\n\\n3. The derivation should be more specific and detailed. If the intention is to directly copy the field from the source table, it should be explicitly mentioned as \"direct\" or provide the field name from the source table for clarity.\\n\\nOverall, the specification for the field \"facility_open_date\" in the target table \"in_FacilityDetails\" needs to be more detailed and precise. It is essential to define the source table, clarify the linking logic, and provide a specific derivation method to accurately map the field. \\n\\nBased on the feedback provided, I would vote **Amber** as the specification needs more work to address the missing source table definition, unclear linking logic, and the need for a more specific derivation method.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'NOVOTE', 'Message': 'I agree with the feedback provided for the field specification:\\n\\n- The linking logic is clear and specifies how Facility_Txn is created by joining FacilityDetails and TxnDetails on the common key facility_id.\\n- The correct identification of the source table as FacilityDetails and the target table as Facility_Txn is accurate.\\n- The identification of the target field as facility_id is also correct.\\n- The derivation method specified as \"direct\" indicates that the value of facility_id should be copied directly from the source table to the target table.\\n\\nBased on the information provided, there are no issues to report, and the spec for this field is valid and clear.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': \"The spec document for the field 'CalcRiskBand' in the 'Account_Facility' table is marked as Red due to the following reasons:\\n1. The linking logic between AccountDetails and FacilityDetails tables is not clearly defined, lacking specific join conditions.\\n2. The derivation logic contains ambiguities such as unclear evaluation criteria for conditions like 'FacilityDetails.RepoTermsAgreed', 'FacilityDetails.Past_Due60Day', and 'AccountDetails.Defaulted'.\\n3. Inconsistency in referencing fields from different source tables without a clear relationship.\\n4. Lack of clarity in handling multiple conditions and their priority levels.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': \"The spec is missing crucial information about the source table for the field 'flagSanctionedEntity', the linking logic, and the derivation logic. Without this information, the spec is incomplete and cannot be implemented accurately.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': 'I agree with the feedback provided:\\n\\n- The linking logic is clear and specifies how Facility_Txn is created by joining FacilityDetails and TxnDetails on the common key facility_id.\\n- The derivation specified as \"direct\" indicates that the value for the field facility_product will be copied directly from the source table FacilityDetails to the target table Facility_Txn.\\n\\nBased on the information provided, the spec for this field seems to be correct and well-defined. No issues to report. \\n\\nTherefore, I will vote Green.'}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec needs more work. The linking logic between the source field 'account_id' in 'in_FacilityDetails' and the target field 'account_id' in 'FacilityDetails' is not defined. More clarification or data is required to ensure the relationship is accurately specified.\"}\n",
      "{'Vote:': 'Red', 'Message': \"The source table and source field for the derivation of the 'flagHighRiskIndustry' field are not defined, making it impossible to determine where the data should come from. Additionally, the linking logic being specified as 'None' leaves ambiguity on how the field should be populated in the target. Please clarify these aspects in the specification.\"}\n",
      "{'Vote:': 'Red', 'Message': 'The spec is incomplete as the source table is not defined for the target field, the linking logic is missing, and the derivation for the target field is not provided. This crucial information needs to be included for proper validation.'}\n",
      "{'Vote:': 'Red', 'Message': \"The source table and source field are not defined, making it impossible to determine where the data for 'facility_country' will be derived from. Additionally, the derivation logic mentioned as 'source field' is unclear and needs to be specified with more clarity.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': 'The spec document is incorrect because the linking logic is not clearly defined, and the derivation logic contains errors and ambiguities. The conditions for setting the AccountLocked field are unclear, and the use of max over aggregated data is not specified. Additionally, the default behavior for setting the field when none of the conditions are met is not defined.'}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec needs more work. Additional information is required to define the source table and clarify the derivation process. The linking logic should be addressed if it exists, and more specific details or examples of the 'source field' should be provided.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Amber', 'Message': \"I will vote Amber because the spec needs more work.\\n\\nThe feedback mentions that the linking logic is not clearly defined, specifically how the 'facility_id' field in 'in_FacilityDetails' is related to the 'facility_id' field in 'FacilityDetails'. More details or context on this relationship would be beneficial for better understanding and implementation.\\n\\nTherefore, further clarification or additional information is required to improve the spec and ensure a more comprehensive understanding of the derivation process.\"}\n",
      "{'Vote:': 'Amber', 'Message': \"The spec needs more work. The source table for the derivation of the `facility_limit` field in the `in_FacilityDetails` table is not specified. Additionally, the linking logic is mentioned as 'None', which needs clarification on how the data will be populated. The derivation mentioned as 'source field' is unclear and requires a more specific explanation or example.\"}\n",
      "{'Vote:': 'Green', 'Message': ''}\n",
      "{'Vote:': 'Red', 'Message': \"The source table 'in_AccountDetails' is not defined, which makes it impossible to implement the linking logic and derivation as specified.\"}\n"
     ]
    }
   ],
   "source": [
    "\n",
    "#Fallback function to vote if no vote is cast\n",
    "def FallBackVote(ret):\n",
    "    text=ret.finalcompletion\n",
    "    text=text.lower()\n",
    "    \n",
    "    #if \"green\" in text\n",
    "    if \"green\" in text:\n",
    "        return VoteResult(\"Green\",ret.finalcompletion)\n",
    "    elif \"amber\" in text:\n",
    "        return VoteResult(\"Amber\",ret.finalcompletion)\n",
    "    elif \"red\" in text:\n",
    "        return VoteResult(\"Red\",ret.finalcompletion)\n",
    "    else:\n",
    "        return VoteResult(\"NOVOTE\",ret.finalcompletion)\n",
    "\n",
    "objects=[]\n",
    "Votes=0\n",
    "NoneVotes=0\n",
    "for ret in results_vote:\n",
    "    if len(ret.funcfusioninstance.emittedObjects)>0:\n",
    "        objects.append(ret.funcfusioninstance.emittedObjects[0])\n",
    "        Votes+=1\n",
    "    else:\n",
    "        #objects.append(VoteResult(\"NOVOTE\",\"NO VOTE:\" + ret.finalcompletion))\n",
    "        objects.append(FallBackVote(ret))\n",
    "        NoneVotes+=1\n",
    "\n",
    "print(f\"Votes: {Votes} NoneVotes: {NoneVotes}\")        \n",
    "\n",
    "for obj in objects:\n",
    "    if obj is not None:\n",
    "        print(obj.to_Json())\n",
    "    else:\n",
    "        print(\"NONE\")\n",
    "\n",
    "\n",
    "#Join the vote results into our dataframe\n",
    "dfRes=[]\n",
    "for i in range(0,len(prompts)):\n",
    "    prompt=prompts[i]\n",
    "    result=results[i].finalcompletion\n",
    "    vote=objects[i]\n",
    "    dictResult={\"Prompt\":prompt,\"Result\":result,\"Vote\":vote.Vote,\"Message\":vote.Message}\n",
    "    dfRes.append(dictResult)\n",
    "\n",
    "df=pd.DataFrame(dfRes)\n",
    "df.to_csv(\"PREFECT_VOTES.csv\",index=False)\n",
    "    "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "pyTorchCUDA",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
