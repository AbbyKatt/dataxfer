{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Batch Lineage RED2GREY Solver"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EntityStore API\n",
    "from ast import List\n",
    "import json\n",
    "\n",
    "class AuditHistory:\n",
    "\n",
    "    def __init__(self,author=\"\",timestamp=\"\",description=\"\"):\n",
    "        self.author = author\n",
    "        self.timestamp = timestamp\n",
    "        self.description = description\n",
    "    \n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"author\":self.author,\n",
    "            \"timestamp\":self.timestamp,\n",
    "            \"description\":self.description\n",
    "        }\n",
    "    \n",
    "    @staticmethod\n",
    "    def from_Json(jsonStr):\n",
    "        self = AuditHistory()\n",
    "        self.author = jsonStr[\"author\"]\n",
    "        self.timestamp = jsonStr[\"timestamp\"]\n",
    "        self.description = jsonStr[\"description\"]\n",
    "        return self\n",
    "\n",
    "#Search result from Dir command\n",
    "class DirResult():\n",
    "\n",
    "    def __init__(self,uuid,Name):\n",
    "        self.uuid = uuid\n",
    "        self.Name = Name\n",
    "\n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"uuid\":self.uuid,\n",
    "            \"Name\":self.Name\n",
    "        }\n",
    "    \n",
    "    def from_Json(self,jsonStr):\n",
    "        self.uuid = jsonStr[\"uuid\"]\n",
    "        self.Name = jsonStr[\"Name\"]\n",
    "\n",
    "#Individual records/simple storage class\n",
    "class MetaRecord:\n",
    "\n",
    "    def __init__(self,uuid=\"\",name=\"\",entityType=\"\",author=\"\",latestUpdate=\"\",keys={},dataFields={},changeHistory=\"\"):\n",
    "        self.uuid = uuid\n",
    "        self.name = name\n",
    "        self.entityType = entityType\n",
    "        self.author = author\n",
    "        self.latestUpdate = latestUpdate\n",
    "        self.changeHistory=changeHistory\n",
    "        self.keys = keys\n",
    "        self.dataFields = dataFields\n",
    "        self.metadata = {}\n",
    "\n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"uuid\":self.uuid,\n",
    "            \"name\":self.name,\n",
    "            \"entityType\":self.entityType,\n",
    "            \"keys\":json.dumps(self.keys),\n",
    "            \"author\":self.author,\n",
    "            \"changeHistory\":self.changeHistory,\n",
    "            \"latestUpdate\":self.latestUpdate,\n",
    "            \"dataFields\":json.dumps(self.dataFields),\n",
    "            \"MetaData\":json.dumps(self.metadata) if self.metadata else \"\"\n",
    "        }\n",
    "    \n",
    "    @staticmethod\n",
    "    def from_Json(jsonStr):\n",
    "        self = MetaRecord()\n",
    "        self.uuid = jsonStr[\"uuid\"]\n",
    "        self.name = jsonStr[\"name\"]\n",
    "        self.entityType = jsonStr[\"entityType\"]\n",
    "        self.author = jsonStr[\"author\"]\n",
    "        self.changeHistory = jsonStr[\"changeHistory\"]\n",
    "        self.latestUpdate = jsonStr[\"latestUpdate\"]\n",
    "\n",
    "        #Load JSON strings into dictionaries\n",
    "        self.keys = {} if \"keys\" not in jsonStr or not jsonStr[\"keys\"] else json.loads(jsonStr[\"keys\"])                  \n",
    "        self.dataFields = {} if \"dataFields\" not in jsonStr or not jsonStr[\"dataFields\"] else json.loads(jsonStr[\"dataFields\"])\n",
    "        self.metadata = {} if \"MetaData\" not in jsonStr or not jsonStr[\"MetaData\"] else json.loads(jsonStr[\"MetaData\"])\n",
    "        return self\n",
    "    \n",
    "    #REST API class for Entity Store -> to be AI converted into VBA classes\n",
    "import requests\n",
    "\n",
    "class EntityStoreRESTAPI:\n",
    "\n",
    "    def __init__(self,baseurl,apikey):\n",
    "        self.baseurl = baseurl\n",
    "        self.api_key = apikey\n",
    "\n",
    "    def api_dir(self,EntityType:str,keys={})->List:\n",
    "        url=f\"{self.baseurl}/EntityStoreDir\"\n",
    "        response = requests.post(url, params={\"EntityType\": EntityType,\"api_key\":self.api_key},json={\"keys\":keys})\n",
    "        response.raise_for_status()\n",
    "        return [DirResult(itm[\"uuid\"], itm[\"Name\"]) for itm in response.json()]\n",
    "\n",
    "    def api_pull(self,EntityType:str,keys={})->List:\n",
    "        url=f\"{self.baseurl}/EntityStorePull\"\n",
    "        response = requests.post(url, params={\"EntityType\": EntityType,\"api_key\":self.api_key},json={\"keys\":keys})\n",
    "        #print(response.json())\n",
    "        response.raise_for_status()\n",
    "        return [MetaRecord.from_Json(itm) for itm in response.json()]\n",
    "\n",
    "    def api_history(self,UUID):\n",
    "        url=f\"{self.baseurl}/EntityStoreHistory\"\n",
    "        response = requests.post(url, params={\"UUID\": UUID,\"api_key\":self.api_key})\n",
    "        response.raise_for_status()\n",
    "        return [AuditHistory.from_Json(itm) for itm in response.json()]\n",
    "    \n",
    "    def api_push(self,records:List,author):\n",
    "        url=f\"{self.baseurl}/EntityStorePush\"\n",
    "        json=[itm.to_Json() for itm in records]\n",
    "        print(json)\n",
    "        response = requests.post(url, params={\"api_key\":self.api_key,\"author\":author},json=json)\n",
    "        print(response)\n",
    "        response.raise_for_status()\n",
    "        return response.json()\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Node model\n",
    "\n",
    "class DependencyNode():\n",
    "    def __init__(self,TableName,FieldName,Dependencies=[],LinkingFields=[],Type=\"Field\",SourceTable=\"AI_Missing_Table\"):\n",
    "        self.TableName=TableName\n",
    "        self.FieldName=FieldName\n",
    "        self.Dependencies=Dependencies\n",
    "        self.LinkingFields=LinkingFields\n",
    "        self.Type=Type\n",
    "        self.SourceTable=SourceTable\n",
    "        \n",
    "        #Compute linkage to other nodes class instances (by key)\n",
    "        self.LeftNodes={}\n",
    "        self.LeftLinkNodes={}\n",
    "        self.RightNodes={}\n",
    "        self.RightLinkNodes={}\n",
    "        \n",
    "        #Deduplication\n",
    "        self.ExistingLinkages={}\n",
    "        \n",
    "    def GetFieldKey(self):\n",
    "        return f\"{self.TableName}.{self.FieldName}\".lower()\n",
    "    \n",
    "    #Build up deduplication on the left side data\n",
    "    def BuildDeduplicationFromLeft(self):\n",
    "        for key in self.LeftNodes:\n",
    "            node=self.LeftNodes[key]\n",
    "            if node.GetFieldKey() not in self.ExistingLinkages:\n",
    "                self.ExistingLinkages[node.GetFieldKey()]=node\n",
    "\n",
    "    #Right link linkage \n",
    "    def AddRightSideLinkageDeduplicated(self,RightNode,isLink=False):\n",
    "        rightKey=RightNode.GetFieldKey()\n",
    "        if rightKey in self.ExistingLinkages:\n",
    "            print(f\"Right Linkage {rightKey} already exists\")\n",
    "            return\n",
    "        else:\n",
    "            #Update deduplication + add to right nodes\n",
    "            #print(f\"Adding Right Linkage {rightKey}\")\n",
    "            self.ExistingLinkages[rightKey]=RightNode\n",
    "            self.RightNodes[rightKey]=RightNode\n",
    "            if isLink:\n",
    "                self.RightLinkNodes[rightKey]=RightNode          \n",
    "            \n",
    "\n",
    "        \n",
    "class DependencyGraph():\n",
    "    def __init__(self):\n",
    "        self.nodes={}\n",
    "    \n",
    "    def AddNode(self,node:DependencyNode):\n",
    "        key=node.GetFieldKey()\n",
    "        if not key in self.nodes:\n",
    "            self.nodes[key]=node\n",
    "        else:\n",
    "            print(f\"Node {key} already exists\")\n",
    "    \n",
    "    def GetFieldKey(self,TableName,FieldName):\n",
    "        node=DependencyNode(TableName,FieldName)\n",
    "        return node.GetFieldKey()\n",
    "\n",
    "    #Split a Table.Field string into it's components, fallbacks to using a default table if no table is found\n",
    "    def MagicSplitFields(self,node:DependencyNode,FieldNotation):\n",
    "        splitStr=FieldNotation.split(\".\")\n",
    "        if len(splitStr)==2:\n",
    "            return (splitStr[0],splitStr[1])\n",
    "        elif len(splitStr)==1:\n",
    "            #Name not fully qualified, assume it's the source table\n",
    "            return (node.SourceTable,splitStr[0])\n",
    "        else:\n",
    "            return (\"AI_Missing_Table\",\"AI_Missing_Field\")\n",
    "\n",
    "    #Function to link all nodes together\n",
    "    def GetLeftLinkNodes(self,linkingName,node,dependencies):\n",
    "        #Walk over every node, linking as we go\n",
    "        missingNodes=0\n",
    "        linkedNodes=0\n",
    "        inputNodes=0\n",
    "        leftNodes={}\n",
    "            \n",
    "        #Build left-side dependency links\n",
    "        for dep in dependencies:\n",
    "            depTable,depField=self.MagicSplitFields(node,dep)\n",
    "            depKey=self.GetFieldKey(depTable,depField)\n",
    "            #print(f\"Linking {key} with {depKey}\")\n",
    "            if depKey in self.nodes:\n",
    "                #Direct link\n",
    "                leftNodes[depKey]=self.nodes[depKey]\n",
    "                linkedNodes+=1\n",
    "            else:\n",
    "                #Dummy link for missing dependency\n",
    "                #get first 3 characters of table name\n",
    "                if depTable[:3]==\"in_\":\n",
    "                    #print(f\"Missing {linkingName} Dependency {depKey}, creating Input Node\")\n",
    "                    dummyNode=DependencyNode(depTable,depField,Type=\"Input\")\n",
    "                    inputNodes+=1    \n",
    "                else:\n",
    "                    print(f\"Missing {linkingName} Dependency {depKey}, creating Dummy Node\")\n",
    "                    dummyNode=DependencyNode(depTable,depField,Type=\"Dummy\")    \n",
    "                    missingNodes+=1\n",
    "                leftNodes[depKey]=dummyNode\n",
    "                \n",
    "\n",
    "        return leftNodes,linkedNodes,missingNodes,inputNodes\n",
    "            \n",
    "    #Verifies and links all nodal (left-side) dependency linkages \n",
    "    #if a node isn't found a dummy node is created to represent it\n",
    "    #Chuck warnings/stats/errors so we can see how the AI solver did\n",
    "    def LeftLinkNodes(self):\n",
    "        \n",
    "        #Walk over every dependency node, linking as we go\n",
    "        missingNodes=0\n",
    "        linkedNodes=0\n",
    "        inputNodes=0\n",
    "        for key in self.nodes:\n",
    "            node=self.nodes[key]\n",
    "            node.LeftNodes,linked,missing,inputNode=self.GetLeftLinkNodes(\"Dependency\",node,node.Dependencies)\n",
    "            linkedNodes+=linked\n",
    "            missingNodes+=missing\n",
    "            inputNodes+=inputNode\n",
    "        print(f\"Linked {linkedNodes} Dependency nodes with {missingNodes} missing and {inputNodes} input nodes\")    \n",
    "\n",
    "        #Walk over every link node, linking as we go\n",
    "        missingNodes=0\n",
    "        linkedNodes=0\n",
    "        inputNodes=0\n",
    "        for key in self.nodes:\n",
    "            node=self.nodes[key]\n",
    "            node.LeftLinkNodes,linked,missing,inputNodes=self.GetLeftLinkNodes(\"Link\",node,node.LinkingFields)\n",
    "            linkedNodes+=linked\n",
    "            missingNodes+=missing\n",
    "            inputNodes+=inputNodes\n",
    "        print(f\"Linked {linkedNodes} Link nodes with {missingNodes} missing and {inputNodes} input nodes\")\n",
    "\n",
    "    #Now the left linkages have been built and validated we can build the right linkages\n",
    "    def RightLinkNodes(self):\n",
    "\n",
    "        #Rebuild node-deduplication on the left side data\n",
    "        print(\"Init Deduplication\")\n",
    "        for key in self.nodes:\n",
    "            node=self.nodes[key]\n",
    "            node.BuildDeduplicationFromLeft()\n",
    "\n",
    "        #Walk through nodes and navigate on left linkages\n",
    "        print(\"Registering Right Linkages\")\n",
    "        for key in self.nodes:\n",
    "            node=self.nodes[key]\n",
    "            \n",
    "            for leftKey in node.LeftNodes:\n",
    "                leftNode=node.LeftNodes[leftKey]\n",
    "                leftNode.AddRightSideLinkageDeduplicated(node,isLink=False)\n",
    "            \n",
    "            for leftKey in node.LeftLinkNodes:\n",
    "                leftNode=node.LeftLinkNodes[leftKey]\n",
    "                leftNode.AddRightSideLinkageDeduplicated(node,isLink=True)\n",
    "            \n",
    "        print(\"Node Linkage Complete!\")\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Graph Solver\n",
    "class GraphAssociationResult():\n",
    "    def __init__(self):\n",
    "        self.TopNode=None\n",
    "        self.ExistingLinks={}   #Prevent infinite recursion\n",
    "        self.Tiers={}\n",
    "        self.MaxTier=0\n",
    "\n",
    "    def HasTraversed(self,Node):\n",
    "        return Node.GetFieldKey() in self.ExistingLinks\n",
    "        \n",
    "    def AddNodeToLayer(self,Node:DependencyNode,Tier):\n",
    "        if Tier not in self.Tiers:\n",
    "            self.Tiers[Tier]={}\n",
    "        if Tier>self.MaxTier:\n",
    "            self.MaxTier=Tier\n",
    "        tierVals=self.Tiers[Tier]\n",
    "        tierVals[Node.GetFieldKey()]=Node        \n",
    "        \n",
    "    #Dumps the last last tier\n",
    "    def NLPUltimateNodes(self,Name):\n",
    "        layer=self.Tiers[self.MaxTier]\n",
    "        print(f\"Final {Name} for {self.TopNode.GetFieldKey()}:\")\n",
    "        for key in layer:\n",
    "            node=layer[key]\n",
    "            print(f\"\\t{node.GetFieldKey()}\")\n",
    "\n",
    "#Error aggregation passed down into recursive functions\n",
    "class ErrorAggregator:\n",
    "    def __init__(self):\n",
    "        self.Errors=[]\n",
    "        self.HasError=False\n",
    "    \n",
    "    def to_Json(self):\n",
    "        return {\n",
    "            \"Errors\":self.Errors,\n",
    "            \"HasError\":self.HasError\n",
    "        }\n",
    "\n",
    "#Solver class for the graph -> walks left and right and does other function (like give ultimate inputs/outputs)\n",
    "class GraphSolver:\n",
    "    \n",
    "    def __init__(self,NodeGraph,ErrorFields=[]):\n",
    "        self.NodeGraph=NodeGraph\n",
    "        self.ErrorFields=ErrorFields\n",
    "        self.debug=False\n",
    "\n",
    "    #Red2Grey solver function\n",
    "    def LeftErrorWalk(self,Node,results:GraphAssociationResult,errorAggregator:ErrorAggregator,errorDict,currentTier=0):\n",
    "        # print(f\"LeftErr Walk {Node.GetFieldKey()}\")\n",
    "        # print(f\"Tier {currentTier}\")\n",
    "        # print(f\"Existing Links {results.ExistingLinks}\")\n",
    "\n",
    "        #Check if this has an error -> tier 0 is exempt\n",
    "        if Node.GetFieldKey() in errorDict and currentTier>0:\n",
    "            error=f\"Error in {Node.GetFieldKey()} : {errorDict[Node.GetFieldKey()]}\\n\"\n",
    "            #print(error)\n",
    "            errorAggregator.Errors.append(error)\n",
    "            errorAggregator.HasError=True\n",
    "            return \n",
    "        \n",
    "        #Recurse on Left Nodes\n",
    "        for key in Node.LeftNodes:\n",
    "            node=Node.LeftNodes[key]           \n",
    "            \n",
    "            if results.HasTraversed(node):\n",
    "                #print(f\"Skipping {node.GetFieldKey()} as already traversed\")\n",
    "                continue\n",
    "            else:\n",
    "                #Stop loops!\n",
    "                results.ExistingLinks[node.GetFieldKey()]=node\n",
    "\n",
    "                #print(f\"\\tLeft Node {node.GetFieldKey()}\")\n",
    "                results.AddNodeToLayer(node,currentTier)                                \n",
    "                self.LeftErrorWalk(node,results,errorAggregator,errorDict,currentTier+1)\n",
    "\n",
    "\n",
    "    #Returns total error count on the pre-requisite nodes\n",
    "    #Used for finding \"ultimate upstream error nodes\" - or nodes that are the source of all errors\n",
    "    def GetUpstreamErrorCount(self,Node,results:GraphAssociationResult,errorAggregator:ErrorAggregator,errorDict,currentTier=0):\n",
    "        \n",
    "        if self.debug:\n",
    "            print(f\"LeftErr Walk {Node.GetFieldKey()}\")\n",
    "            print(f\"Tier {currentTier}\")\n",
    "            print(f\"Existing Links {results.ExistingLinks}\")\n",
    "        \n",
    "        #If this node has passed testing...\n",
    "        if Node.GetFieldKey() not in errorDict:\n",
    "            #Stop iterating and return 0\n",
    "            if self.debug:\n",
    "                print(f\"Node f{Node.GetFieldKey()} has no errors - stopping enumeration\")\n",
    "            return 0\n",
    "        \n",
    "        #Recurse on Left Nodes\n",
    "        upstreamErrorCount=0\n",
    "        for key in Node.LeftNodes:\n",
    "            node=Node.LeftNodes[key]           \n",
    "            \n",
    "            if results.HasTraversed(node):\n",
    "                if self.debug:\n",
    "                    print(f\"Skipping {node.GetFieldKey()} as already traversed\")\n",
    "                continue\n",
    "            else:\n",
    "                #Stop loops!\n",
    "                results.ExistingLinks[node.GetFieldKey()]=node\n",
    "                results.AddNodeToLayer(node,currentTier)                                \n",
    "                upstreamErrorCount+=self.GetUpstreamErrorCount(node,results,errorAggregator,errorDict,currentTier+1)\n",
    "\n",
    "        #State collapse - we now have upstream errors\n",
    "        if upstreamErrorCount==0:\n",
    "            #Either there are no more nodes or they all tested green - this FIELD is probably the source of the error\n",
    "            if self.debug:\n",
    "                print(f\"Ultimate Error Node {Node.GetFieldKey()} ending enumeration\")\n",
    "            errorAggregator.Errors.append(Node.GetFieldKey())\n",
    "        \n",
    "        return upstreamErrorCount\n",
    "            \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "#LineageSolverAPI class -> solves dependencies between fields\n",
    "import pandas as pd\n",
    "\n",
    "class LineageSolverAPI():\n",
    "    \n",
    "    def __init__(self,EntityStoreURL,api_key,tableUUID):\n",
    "        self.EntStoreURL=EntityStoreURL\n",
    "        self.api_key=api_key\n",
    "        self.tableUUID=tableUUID\n",
    "        self.NodeGraph=None\n",
    "        self.Solver=None\n",
    "    \n",
    "    #Wrangle the potentially unreliable metadata field\n",
    "    def MetaWrangleDep(self,meta):\n",
    "        try:\n",
    "            dep=meta[\"Dependencies\"]\n",
    "            return json.dumps(dep) if dep else \"\"\n",
    "        except:\n",
    "            return \"\"\n",
    "\n",
    "    def MetaWrangleLinks(self,meta):\n",
    "        try:\n",
    "            dep=meta[\"LinkFields\"]\n",
    "            return json.dumps(dep) if dep else \"\"\n",
    "        except:\n",
    "            return \"\"\n",
    "        \n",
    "    def GracefulJSON(self,jsonStr):\n",
    "        try:\n",
    "            return json.loads(jsonStr)\n",
    "        except:\n",
    "            return []\n",
    "    \n",
    "    def LoadGraph(self):\n",
    "        #Load data from EntityStore into a dataframe\n",
    "        entStore=EntityStoreRESTAPI(self.EntStoreURL,self.api_key)\n",
    "\n",
    "        #Load this specific fields for this table\n",
    "        entities=entStore.api_pull(\"Field\",{\"TableUUID\":self.tableUUID})\n",
    "        rows=[]\n",
    "        for metaRec in entities:\n",
    "            datafields=metaRec.dataFields\n",
    "            datafields[\"uuid\"]=metaRec.uuid\n",
    "            datafields[\"metadata\"]=metaRec.metadata\n",
    "            rows.append(datafields)\n",
    "\n",
    "        #Turn rows into a DataFrame\n",
    "        df=pd.DataFrame(rows)\n",
    "        #df.head()\n",
    "\n",
    "        #Wrangle data into a graph format for loading\n",
    "        TargetTable=df[\"Target Table\"]\n",
    "        TargetField=df[\"Target Field\"]\n",
    "        SourceTable=df[\"Source Table\"]\n",
    "\n",
    "        #Depdencies from the metadata\n",
    "        MetaData=df[\"metadata\"]\n",
    "        Dependencies=[self.MetaWrangleDep(meta) for meta in MetaData]\n",
    "        LinkFields=[self.MetaWrangleLinks(meta) for meta in MetaData]\n",
    "\n",
    "        #Build new dataframe\n",
    "        dfGraph=pd.DataFrame({\"TableName\":TargetTable,\"FieldName\":TargetField,\"Dependencies\":Dependencies,\"LinkingFields\":LinkFields,\"SourceTable\":SourceTable})\n",
    "        dfGraph.head()\n",
    "        \n",
    "        #Stage 1 of Graph Solver: Registration\n",
    "        NodeGraph=DependencyGraph()\n",
    "        for iter,row in dfGraph.iterrows():\n",
    "            TableName=row[\"TableName\"]\n",
    "            FieldName=row[\"FieldName\"]\n",
    "            Dependencies=row[\"Dependencies\"]\n",
    "            LinkingFields=row[\"LinkingFields\"]\n",
    "            SourceTable=row[\"SourceTable\"]\n",
    "            \n",
    "            #Adding node - at this point Depdencies and LinkingFields are just list of strings in form TableName.FieldName\n",
    "            #Sometimes without TableName -> MagicFieldSplit will try to guess the table name\n",
    "            node=DependencyNode(TableName,FieldName,self.GracefulJSON(Dependencies),self.GracefulJSON(LinkingFields),SourceTable=SourceTable)\n",
    "            NodeGraph.AddNode(node)      \n",
    "            \n",
    "        #Stage 2 of Graph Solver: Left-Linking\n",
    "        #Promotes the loose string dependencies into actual node dependencie\n",
    "        #LeftNodes and LeftLinkNodes are now lists of actual node instances\n",
    "        NodeGraph.LeftLinkNodes()\n",
    "\n",
    "        #Stage 3: use the validated ad linked left side nodes to call the RightLinkNodes function\n",
    "        #think of this as the neighbour to the the right of you calling you up to say they depend on you :)\n",
    "        NodeGraph.RightLinkNodes()\n",
    "  \n",
    "        #Done\n",
    "        self.NodeGraph=NodeGraph\n",
    "        self.Solver=GraphSolver(NodeGraph)  \n",
    "\n",
    "\n",
    "    def GetFieldColour(self,tableName,fieldName,errorDict):\n",
    "        #print(f\"Getting Field Colour {tableName}.{fieldName}\")        \n",
    "        tabledotfield=f\"{tableName}.{fieldName}\".lower()\n",
    "        if tabledotfield not in self.NodeGraph.nodes:\n",
    "            #return (\"PURPLE\",\"Not Found\")    #Not found!\n",
    "            return {\"Table\":tableName,\"Field\":fieldName,\"status\":\"PURPLE\",\"error\":[\"Field not found!\"],\"hints\":[]}\n",
    "        \n",
    "        #Top level field is green -> don't dive down\n",
    "        if tabledotfield not in errorDict:\n",
    "            #return (\"GREEN\",\"\")\n",
    "            return {\"Table\":tableName,\"Field\":fieldName,\"status\":\"GREEN\",\"error\":[],\"hints\":[]}\n",
    "\n",
    "        # #Do a walk and return NLP result\n",
    "        errorAgg=ErrorAggregator()\n",
    "        node=self.NodeGraph.nodes[tabledotfield]\n",
    "        results=GraphAssociationResult()\n",
    "        self.Solver.LeftErrorWalk(node,results,errorAgg,errorDict)\n",
    "        #print(errorAgg.to_Json())\n",
    "        \n",
    "        #Final result\n",
    "        if errorAgg.HasError:\n",
    "            return {\"Table\":tableName,\"Field\":fieldName,\"status\":\"GREY\",\"error\":errorAgg.Errors,\"hints\":[]}\n",
    "        \n",
    "        else:\n",
    "            #return (\"RED\",\"\")\n",
    "            return {\"Table\":tableName,\"Field\":fieldName,\"status\":\"RED\",\"error\":[],\"hints\":[]}\n",
    "    \n",
    "    \n",
    "    #Get the leftmost nodes with errors -> or the ultimate upstream error nodes (the source of all errors)\n",
    "    def GetUltimateErrorNodes(self,tableName,fieldName,errorDict):\n",
    "        tabledotfield=f\"{tableName}.{fieldName}\".lower()\n",
    "        if tabledotfield not in self.NodeGraph.nodes:\n",
    "            return []\n",
    "\n",
    "        errorAgg=ErrorAggregator()\n",
    "        node=self.NodeGraph.nodes[tabledotfield]\n",
    "        results=GraphAssociationResult()\n",
    "        upstreamErrors=self.Solver.GetUpstreamErrorCount(node,results,errorAgg,errorDict)\n",
    "        return errorAgg.Errors\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Load Error Dictionary\n",
    "errorDict={}\n",
    "sql=\"SELECT TableName,ColumnName,CountError FROM `datawx.Causality_BaseLine.vw_Errors` LIMIT 1000\"\n",
    "dfErrors=pd.read_gbq(sql,project_id=\"datawx\",dialect=\"standard\")\n",
    "\n",
    "#Combine TableName and ColumnName into string for each row\n",
    "dfErrors[\"TableField\"]=dfErrors[\"TableName\"]+\".\"+dfErrors[\"ColumnName\"]\n",
    "for iter,row in dfErrors.iterrows():\n",
    "    tableField=row[\"TableField\"]\n",
    "    cerr=row[\"CountError\"]\n",
    "    errorDict[tableField.lower()]=f\"{cerr} total errors\"\n",
    "\n",
    "#errorDict\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Missing Dependency Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Dependency Dependency none.source field, creating Dummy Node\n",
      "Missing Dependency Dependency accountdetails.defaulted, creating Dummy Node\n",
      "Linked 78 Dependency nodes with 3 missing and 4 input nodes\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Missing Link Dependency txndetails.facility_id, creating Dummy Node\n",
      "Linked 71 Link nodes with 14 missing and 0 input nodes\n",
      "Init Deduplication\n",
      "Registering Right Linkages\n",
      "Right Linkage txndetails.txn_id already exists\n",
      "Right Linkage txndetails.txn_date already exists\n",
      "Right Linkage facility_txn.facility_id already exists\n",
      "Right Linkage account_facility.account_id already exists\n",
      "Node Linkage Complete!\n"
     ]
    }
   ],
   "source": [
    "#Load data and setup Lineage Solver\n",
    "\n",
    "EntStoreURL=\"https://entitystore.datawx.uk\"\n",
    "tableUUID=\"782b86f8-a297-4131-bf1a-cb66f1dc6f13\"\n",
    "apiKey=\"entity_store_api_key\"\n",
    "\n",
    "iLineageSolver=LineageSolverAPI(EntStoreURL,apiKey,tableUUID)\n",
    "iLineageSolver.LoadGraph()\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Tests\n",
    "#print(iLineageSolver.GetFieldColour(\"AccountUsage\",\"summed_facility_limit\",errorDict))\n",
    "#print(iLineageSolver.GetFieldColour(\"AccountUsage\",\"branch_code\",errorDict))\n",
    "#print(iLineageSolver.GetUltimateErrorNodes(\"AccountUsage\",\"summed_txn_amount\",errorDict))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "#GetFieldPrerequisiteTables(\"TxnDetails\",\"txn_country\")\n",
    "\n",
    "#GetFieldPrerequisite(\"AccountUsage\",\"summed_facility_limit\")\n",
    "#GetFieldDependencies(\"AccountUsage,fieldName=summed_facility_limit)\n",
    "\n",
    "# GetFieldDependencies(\"TxnDetails\",\"txn_amount\")\n",
    "# GetFieldPrerequisiteTables(\"TxnDetails\",\"txn_amount\")\n",
    "# GetFieldDependentTables(\"TxnDetails\",\"txn_amount\")\n",
    "\n",
    "\n",
    "# GetFieldPrerequisite(\"AccountUsage\",\"account_open_date\")\n",
    "# GetFieldDependencies(\"AccountUsage\",\"account_open_date\")\n",
    "# GetFieldPrerequisiteTables(\"AccountUsage\",\"account_open_date\")\n",
    "# GetFieldDependentTables(\"AccountUsage\",\"account_open_date\")\n",
    " \n",
    "# #Field not found test\n",
    "# GetFieldDependentTables(\"HURR\",\"DURR\")\n",
    "# GetFieldDependencies(\"HURR\",\"DURR\")\n",
    "# GetFieldPrerequisite(\"HURR\",\"DURR\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['AccountUsage',\n",
       " 'FacilityDetails',\n",
       " 'Facility_Txn',\n",
       " 'AccountDetails',\n",
       " 'in_FacilityDetails',\n",
       " 'in_AccountDetails',\n",
       " 'Account_Facility',\n",
       " 'RAFTFilteredResults',\n",
       " 'TxnDetails',\n",
       " 'in_TxnDetails']"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Get list of tables for datset\n",
    "import pandas as pd\n",
    "dataset=\"datawx.Causality_BaseLine\"\n",
    "sql=f\"\"\"SELECT table_name\n",
    "FROM `{dataset}.INFORMATION_SCHEMA.TABLES`\n",
    "WHERE table_type = 'BASE TABLE';\"\"\"\n",
    "df=pd.read_gbq(sql,project_id=\"datawx\",dialect=\"standard\")\n",
    "df\n",
    "ExcludedTables={\"RAFTResults\":True}\n",
    "\n",
    "#Turn DF table_name into list after removing excluded tables\n",
    "TestTables=[table for table in df[\"table_name\"] if table not in ExcludedTables]\n",
    "TestTables\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processing AccountUsage\n",
      "Processing FacilityDetails\n",
      "Processing Facility_Txn\n",
      "Processing AccountDetails\n",
      "Processing in_FacilityDetails\n",
      "Processing in_AccountDetails\n",
      "Processing Account_Facility\n",
      "Processing RAFTFilteredResults\n",
      "Processing TxnDetails\n",
      "Processing in_TxnDetails\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[{'Table': 'AccountUsage',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'account_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'branch_code',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in account_facility.branch_code : 10 total errors\\n'],\n",
       "  'hints': ['in_accountdetails.branch_code',\n",
       "   'accountdetails.branch_code',\n",
       "   'account_facility.branch_code',\n",
       "   'accountusage.branch_code']},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'customer_name',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'account_type',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'old_account_type',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'summed_facility_limit',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in account_facility.facility_limit : 6 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_limit',\n",
       "   'facilitydetails.facility_limit',\n",
       "   'account_facility.facility_limit',\n",
       "   'accountusage.summed_facility_limit']},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'summed_txn_amount',\n",
       "  'status': 'RED',\n",
       "  'error': [],\n",
       "  'hints': ['accountusage.summed_txn_amount']},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'AccountReviewRequired',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'AccountLocked',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountUsage',\n",
       "  'Field': 'CalcRiskBand',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'facility_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'facility_product',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'facility_type',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in in_facilitydetails.facility_type : 9 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_type',\n",
       "   'facilitydetails.facility_type']},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'facility_limit',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in in_facilitydetails.facility_limit : 3 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_limit',\n",
       "   'facilitydetails.facility_limit']},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'facility_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'facility_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in in_facilitydetails.account_id : 3 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.account_id', 'facilitydetails.account_id']},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'Past_Due60Day',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'RepoTermsAgreed',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'flagSanctionedEntity',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'flagUnusualActivity',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'FacilityDetails',\n",
       "  'Field': 'flagHighRiskIndustry',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'facility_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'facility_product',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'facility_type',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in facilitydetails.facility_type : 9 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_type',\n",
       "   'facilitydetails.facility_type',\n",
       "   'facility_txn.facility_type']},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'facility_limit',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in facilitydetails.facility_limit : 3 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_limit',\n",
       "   'facilitydetails.facility_limit',\n",
       "   'facility_txn.facility_limit']},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'facility_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'facility_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in facilitydetails.account_id : 3 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.account_id',\n",
       "   'facilitydetails.account_id',\n",
       "   'facility_txn.account_id']},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'txn_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'txn_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'txn_amount',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'txn_type',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in txndetails.txn_type : 53 total errors\\n'],\n",
       "  'hints': ['in_txndetails.txn_type',\n",
       "   'txndetails.txn_type',\n",
       "   'facility_txn.txn_type']},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'txn_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'flagFraudSuspected',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Facility_Txn',\n",
       "  'Field': 'flagSuspectTransfer',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'account_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'branch_code',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in in_accountdetails.branch_code : 2 total errors\\n'],\n",
       "  'hints': ['in_accountdetails.branch_code', 'accountdetails.branch_code']},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'customer_name',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'account_type',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'Defaulted',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'CreditRiskBand',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'flagPEPExposed',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'AccountDetails',\n",
       "  'Field': 'flagHighRiskCountry',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'facility_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'facility_product',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'facility_type',\n",
       "  'status': 'RED',\n",
       "  'error': [],\n",
       "  'hints': ['in_facilitydetails.facility_type']},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'facility_limit',\n",
       "  'status': 'RED',\n",
       "  'error': [],\n",
       "  'hints': ['in_facilitydetails.facility_limit']},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'facility_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'facility_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'RED',\n",
       "  'error': [],\n",
       "  'hints': ['in_facilitydetails.account_id']},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'Past_Due60Day',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'RepoTermsAgreed',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'flagSanctionedEntity',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'flagUnusualActivity',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_FacilityDetails',\n",
       "  'Field': 'flagHighRiskIndustry',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'account_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'branch_code',\n",
       "  'status': 'RED',\n",
       "  'error': [],\n",
       "  'hints': ['in_accountdetails.branch_code']},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'customer_name',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'account_type',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'Defaulted',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'CreditRiskBand',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'flagPEPExposed',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_AccountDetails',\n",
       "  'Field': 'flagHighRiskCountry',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'account_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'account_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'branch_code',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in accountdetails.branch_code : 2 total errors\\n'],\n",
       "  'hints': ['in_accountdetails.branch_code',\n",
       "   'accountdetails.branch_code',\n",
       "   'account_facility.branch_code']},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'customer_name',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'account_type',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'flagPEPExposed',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'flagHighRiskCountry',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'old_account_type',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'facility_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'facility_product',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'facility_type',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in facilitydetails.facility_type : 9 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_type',\n",
       "   'facilitydetails.facility_type',\n",
       "   'account_facility.facility_type']},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'facility_limit',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in facilitydetails.facility_limit : 3 total errors\\n'],\n",
       "  'hints': ['in_facilitydetails.facility_limit',\n",
       "   'facilitydetails.facility_limit',\n",
       "   'account_facility.facility_limit']},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'facility_open_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'facility_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'flagSanctionedEntity',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'flagUnusualActivity',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'flagHighRiskIndustry',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'Account_Facility',\n",
       "  'Field': 'CalcRiskBand',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'RAFTFilteredResults',\n",
       "  'Field': 'Table',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'RAFTFilteredResults',\n",
       "  'Field': 'Field',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'RAFTFilteredResults',\n",
       "  'Field': 'status',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'RAFTFilteredResults',\n",
       "  'Field': 'error',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'RAFTFilteredResults',\n",
       "  'Field': 'hints',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'txn_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'txn_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'txn_amount',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'txn_type',\n",
       "  'status': 'GREY',\n",
       "  'error': ['Error in in_txndetails.txn_type : 53 total errors\\n'],\n",
       "  'hints': ['in_txndetails.txn_type', 'txndetails.txn_type']},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'txn_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'flagFraudSuspected',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'flagSuspectTransfer',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'TxnDetails',\n",
       "  'Field': 'facility_id',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'txn_id',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'txn_date',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'txn_amount',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'txn_type',\n",
       "  'status': 'RED',\n",
       "  'error': [],\n",
       "  'hints': ['in_txndetails.txn_type']},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'txn_country',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'flagFraudSuspected',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'flagSuspectTransfer',\n",
       "  'status': 'GREEN',\n",
       "  'error': [],\n",
       "  'hints': []},\n",
       " {'Table': 'in_TxnDetails',\n",
       "  'Field': 'facility_id',\n",
       "  'status': 'PURPLE',\n",
       "  'error': ['Field not found!'],\n",
       "  'hints': []}]"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "#Batch Table Solve Prototype\n",
    "TestSet=\"Causality_BaseLine\"\n",
    "\n",
    "\n",
    "def GetFieldNames(TestSet,TableName):\n",
    "    sql=f\"SELECT * FROM {TestSet}.{TableName} LIMIT 1\"\n",
    "    df=pd.read_gbq(sql,project_id=\"datawx\",dialect=\"standard\")\n",
    "    return df.columns.tolist()\n",
    "\n",
    "\n",
    "def BatchGetFieldColours(TestSet,TableName,errorDict):\n",
    "    fieldNames=GetFieldNames(TestSet,TableName)\n",
    "    \n",
    "    results=[]\n",
    "    for fieldName in fieldNames:\n",
    "        if fieldName not in [\"id\",\"CPK\"]:\n",
    "            result=iLineageSolver.GetFieldColour(TableName,fieldName,errorDict)\n",
    "            hints=iLineageSolver.GetUltimateErrorNodes(TableName,fieldName,errorDict)\n",
    "            result.update({\"hints\":hints}) #Add hints to the result dictionary\n",
    "            results.append (result)\n",
    "    \n",
    "    return results\n",
    "\n",
    "#BatchGetFieldColours(TestSet,\"AccountUsage\",errorDict)\n",
    "TestResults=[]\n",
    "for Table in TestTables:\n",
    "    print(f\"Processing {Table}\")\n",
    "    result=BatchGetFieldColours(TestSet,Table,errorDict)\n",
    "    for res in result:\n",
    "        TestResults.append(res)\n",
    "\n",
    "\n",
    "#Json encode the error and hints fields as strings\n",
    "# for res in TestResults:\n",
    "#     res[\"error\"]=json.dumps(res[\"error\"])\n",
    "#     res[\"hints\"]=json.dumps(res[\"hints\"])\n",
    "\n",
    "TestResults\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 1/1 [00:00<?, ?it/s]\n"
     ]
    }
   ],
   "source": [
    "#TestResults\n",
    "for res in TestResults:\n",
    "    res[\"error\"]=json.dumps(res[\"error\"])\n",
    "    res[\"hints\"]=json.dumps(res[\"hints\"])\n",
    "\n",
    "\n",
    "#turn into a dataframe\n",
    "dfResults=pd.DataFrame(TestResults)\n",
    "dfResults.head()\n",
    "\n",
    "#Persist to BigQuery\n",
    "dfResults.to_gbq(f\"{TestSet}.RAFTFilteredResults\",project_id=\"datawx\",if_exists=\"replace\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
